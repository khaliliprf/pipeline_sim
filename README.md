

## 📘 توابع اصلی کلاس `Pipeline`

---

### ✅ `__init__(...)`

**هدف:** مقداردهی اولیه به تمام ویژگی‌های پایپ‌لاین

* `instructions`: لیست اولیه دستورات (لیستی از اشیای Instruction).
* `enable_forwarding`: مشخص می‌کند فورواردینگ فعال باشد یا نه.
* شمارنده‌های آماری: `stall_count`, `flush_count`, `forward_count`, `structural_stalls`.
* `pipeline_registers`: دیکشنری ۵ استیجی (IF, ID, EX, MEM, WB).
* `pipeline_matrix`: ذخیره‌ی زمان و مکان عبور هر دستور در پایپ‌لاین.
* `completed_instructions`: لیست دستوراتی که وارد WB شده‌اند.
* `input_instructions_count`: تعداد دستورات اولیه، برای گزارش نهایی.

---

### ✅ `log_pipeline_stage(instr, stage)`

**هدف:** ثبت اینکه یک دستور در کدام کلاک وارد کدام استیج شده است.

* اگر دستور اولین بار دیده می‌شود، یک ورودی برایش در `pipeline_matrix` ایجاد می‌شود.
* سپس مقدار `stage` برای `self.clock` در آن ثبت می‌شود.

---

### ✅ `has_raw_hazard(curr_instr)`

**هدف:** بررسی وابستگی داده‌ای از نوع RAW (Read After Write)

* `sources`: رجیسترهای ورودی دستور فعلی (`rs`, `rt`)
* برای هر استیج جلوتر (EX, MEM, WB)، بررسی می‌شود که آیا مقصد یک دستور قبلی با یکی از `sources` برابر است یا نه.
* اگر `enable_forwarding` فعال باشد:

  * اگر داده هنوز در EX است و دستور قبلی `LW` باشد: استثنا → نیاز به استال
  * در غیر این صورت → فوروارد انجام می‌شود و `forward_count` افزایش می‌یابد.
* اگر فورواردینگ غیرفعال باشد → استال ضروری است.

---

### ✅ `tick()`

**هدف:** شبیه‌سازی یک سیکل کلاک پایپ‌لاین

1. **افزایش شمارنده کلاک**

2. **مرحله WB:**

   * هر دستوری که در `WB` هست به عنوان تمام‌شده علامت‌گذاری می‌شود.
   * به لیست `completed_instructions` اضافه می‌شود.
   * پاک‌سازی استیج WB برای کلاک بعدی.

3. **جابه‌جایی مراحل:**

   * `MEM → WB`
   * `EX → MEM`

4. **بررسی استیج ID برای رفتن به EX:**

   * اگر دستور `BEQ` باشد و شرط branch برقرار نباشد:

     * تمام دستورات موجود در `IF` و `ID` حذف (flush)
     * شمارش `flush_count`
   * اگر hazard موجود باشد:

     * استال در EX
     * افزایش `stall_count`
   * در غیر این صورت:

     * انتقال دستور از `ID → EX`

5. **بررسی امکان آوردن دستور جدید به IF و انتقال به ID:**

   * شرط `can_fetch_new` بررسی می‌کند که:

     * یا ID خالی باشد، یا دستور در ID بدون hazard باشد.
   * اگر امکان باشد:

     * دستور بعدی از `instructions` وارد IF می‌شود.
     * سپس `IF → ID` می‌شود.

6. **ثبت وضعیت همه دستورات در ماتریس پایپ‌لاین**

---

### ✅ `is_done()`

**هدف:** بررسی اینکه اجرای تمام دستورات به پایان رسیده یا نه

* با بررسی اینکه آیا تعداد دستورات کامل‌شده برابر با کل تعداد دستورها (و وضعیت استیج‌ها) است یا نه.

---

### ✅ `total_instruction_count()`

**هدف:** جمع کل دستوراتی که یا هنوز اجرا نشده‌اند یا در حال اجرا هستند یا اجرا شده‌اند.

---

### ✅ `run(...)`

**هدف:** اجرای پایپ‌لاین تا اتمام برنامه یا رسیدن به حداکثر کلاک

* در یک حلقه `while`، مرتباً `tick()` فراخوانی می‌شود.
* سپس ماتریس نهایی و آمار چاپ می‌شود.
* داده‌ها برای رسم گراف نهایی به `export_simulation_image` فرستاده می‌شوند.

---

### ✅ `print_stats()`

**هدف:** چاپ آمار نهایی اجرای برنامه

* شامل: total cycles, number of instructions, stalls, flushes, forwards, CPI

---

### ✅ `print_pipeline_matrix()`

**هدف:** چاپ جدول پایپ‌لاین به‌صورت متنی

* سطر اول: شماره کلاک‌ها
* هر سطر بعدی: مراحل اجرای یک دستور
* اگر دستوری flush شده باشد → `--` در جدول

---